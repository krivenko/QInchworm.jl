var documenterSearchIndex = {"docs":
[{"location":"example/#example","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The following example demonstrates solution of the single orbital Anderson model in thermodynamic equilibrium coupled to a fermionic bath with a semi-elliptic density of states. We compute the single-particle Green's function, the dynamical double-occupancy and the transversal magnetic susceptibility of the impurity. The resulting curves are shown above.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(read(\"example/example.jl\", String))\n```\n\"\"\")","category":"page"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics","text":"","category":"section"},{"location":"modules/diagrammatics/","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics","text":"CurrentModule = QInchworm.diagrammatics","category":"page"},{"location":"modules/diagrammatics/","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics","text":"diagrammatics\nTopology\nTopology(::PairVector)\nparity\nBase.isvalid(::Topology)\nsortpair\npop_pair\npair_partitions\niscrossing\nn_crossings\ntraverse_crossing_graph_dfs!\nis_k_connected\nsplit_k_connected\nis_doubly_k_connected\ncount_doubly_k_connected\nsplit_doubly_k_connected\ngenerate_topologies\ngenerate_topologies_impl\nget_topologies_at_order","category":"page"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics","text":"Strong coupling expansion diagrams and their topological properties.\n\n\n\n\n\n","category":"module"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics.Topology","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics.Topology","text":"struct Topology\n\nDatatype for strong coupling diagram topology.\n\nA topology of order n consists of a partition of the tuple s = 12n into n pairs (pi(1) pi(2))  (pi(2n-1) pi(2n)) where pi is a permutation of s. Diagrammatically, a topology can be thought of as a set of arcs connecting vertices located at 12n. The parity of the topology is the sign of the permutation pi.\n\nFields\n\norder::Int64: Topology order n\npairs::Vector{Pair{Int64, Int64}}: List of pairs (pi(1) pi(2))  (pi(2n-1) pi(2n))\nparity::Int64: Parity of the permutation pi\n\n\n\n\n\n","category":"type"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics.Topology-Tuple{Vector{Pair{Int64, Int64}}}","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics.Topology","text":"Topology(\n    pairs::Vector{Pair{Int64, Int64}}\n) -> QInchworm.diagrammatics.Topology\n\n\nConstruct topology from a list of pairs.\n\n\n\n\n\n","category":"method"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics.parity","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics.parity","text":"parity(top::QInchworm.diagrammatics.Topology) -> Int64\n\n\nReturns the parity of the topolgy.\n\n\n\n\n\n","category":"function"},{"location":"modules/diagrammatics/#Base.isvalid-Tuple{QInchworm.diagrammatics.Topology}","page":"QInchworm.diagrammatics","title":"Base.isvalid","text":"isvalid(t::QInchworm.diagrammatics.Topology) -> Bool\n\n\nCheck that topology is properly constructed, i.e. that its list of pairs is derived from a permutation of 1:2order and that the parity of the permutation is correct.\n\n\n\n\n\n","category":"method"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics.sortpair","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics.sortpair","text":"sortpair(p::Pair{T, T}) -> Pair\n\n\nGiven a pair, return its version with the smallest element coming first.\n\n\n\n\n\n","category":"function"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics.pop_pair","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics.pop_pair","text":"pop_pair(v::Vector, i, j) -> Tuple{Pair, Any}\n\n\nReturn the pair v[i] => v[j] and a copy of the vector v with elements i, j removed.\n\n\n\n\n\n","category":"function"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics.pair_partitions","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics.pair_partitions","text":"pair_partitions(\n    pairs::Vector{Pair{Int64, Int64}},\n    unpaired::Vector{Int64}\n) -> Vector{Vector{Pair{Int64, Int64}}}\n\n\nGiven a vector of pairs representing a partial partition of the vertices and a vector of unpaired vertices, return a vector of complete partitions.\n\n\n\n\n\npair_partitions(\n    vertices::Vector{Int64}\n) -> Vector{Vector{Pair{Int64, Int64}}}\n\n\nReturn all possible partitions of an even number of vertices into pairs.\n\n\n\n\n\npair_partitions(\n    n::Int64\n) -> Vector{Vector{Pair{Int64, Int64}}}\n\n\nReturn all partitions of 1ldots2n into n pairs.\n\n\n\n\n\n","category":"function"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics.iscrossing","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics.iscrossing","text":"iscrossing(\n    p1::Pair{Int64, Int64},\n    p2::Pair{Int64, Int64}\n) -> Bool\n\n\nReturn true if two arcs cross.\n\nLet p_1 = (a_1 b_1), p_2 = (a_2 b_2) represent two arcs, where without loss of generality we assume a_1  b_1 and a_2  b_2. Now consider the order of the points a_1 b_1 a_2 b_2. The orderings a_1 b_1 a_2 b_2, a_1 a_2 b_2 b_1, a_2 b_2 a_1 b_1 are all non-crossing while a_1 a_2 b_1 b_2 and a_2 a_1 b_2 b_1 are crossing.\n\n\n\n\n\n","category":"function"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics.n_crossings","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics.n_crossings","text":"n_crossings(top::QInchworm.diagrammatics.Topology) -> Int64\n\n\nReturn the number of crossing arcs in a topology.\n\n\n\n\n\n","category":"function"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics.traverse_crossing_graph_dfs!","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics.traverse_crossing_graph_dfs!","text":"traverse_crossing_graph_dfs!(\n    connected::Vector{Pair{Int64, Int64}},\n    disconnected::Vector{Pair{Int64, Int64}}\n)\n\n\nGiven a vector of connected arcs and a vector of disconnected arcs recursively add disconnected to connected if they cross with any connected. This is done by traversing the crossing graph using depth first search.\n\n\n\n\n\n","category":"function"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics.is_k_connected","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics.is_k_connected","text":"is_k_connected(\n    t::QInchworm.diagrammatics.Topology,\n    k::Int64\n) -> Bool\n\n\nGiven a topology, check if every connected component of the graph induced by crossings between the arcs contains a pair with an element <= k.\n\n\n\n\n\n","category":"function"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics.split_k_connected","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics.split_k_connected","text":"split_k_connected(\n    pairs::Vector{Pair{Int64, Int64}},\n    k::Int64\n) -> Tuple{Vector{Pair{Int64, Int64}}, Vector{Pair{Int64, Int64}}}\n\n\nGiven a vector of integer pairs, split it into a connected set containing pairs with an element <= k and a disconnected set containing the rest.\n\n\n\n\n\n","category":"function"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics.is_doubly_k_connected","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics.is_doubly_k_connected","text":"is_doubly_k_connected(\n    p::Pair{Int64, Int64},\n    k::Int64\n) -> Bool\n\n\nReturn true if a given integer pair has one element <= k and the other element > k.\n\n\n\n\n\nis_doubly_k_connected(\n    t::QInchworm.diagrammatics.Topology,\n    k::Int64\n) -> Bool\n\n\nGiven a topology, check if every connected component of the graph induced by crossings between the arcs contains a pair with one element <= k and the other element > k.\n\n\n\n\n\n","category":"function"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics.count_doubly_k_connected","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics.count_doubly_k_connected","text":"count_doubly_k_connected(\n    pairs::Vector{Pair{Int64, Int64}},\n    k::Int64\n) -> Int64\n\n\nGiven a vector of integer pairs, count the doubly k-connected ones.\n\n\n\n\n\n","category":"function"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics.split_doubly_k_connected","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics.split_doubly_k_connected","text":"split_doubly_k_connected(\n    pairs::Vector{Pair{Int64, Int64}},\n    k::Int64\n) -> Tuple{Vector{Pair{Int64, Int64}}, Vector{Pair{Int64, Int64}}}\n\n\nGiven a vector of integer pairs, split it into a connected set containing pairs with one element <= k and the other element > k, and a disconnected set containing the rest.\n\n\n\n\n\n","category":"function"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics.generate_topologies","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics.generate_topologies","text":"generate_topologies(\n    n::Int64\n) -> Vector{QInchworm.diagrammatics.Topology}\n\n\nReturn topologies of order n, efficiently computing the permutation sign for each.\n\n\n\n\n\n","category":"function"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics.generate_topologies_impl","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics.generate_topologies_impl","text":"generate_topologies_impl(\n    topology_partial::QInchworm.diagrammatics.Topology,\n    unpaired::Vector{Int64}\n) -> Vector{QInchworm.diagrammatics.Topology}\n\n\nGiven a partial topology and a vector of unpaired vertices, return a vector of complete topologies, efficiently computing the permutation sign.\n\n\n\n\n\n","category":"function"},{"location":"modules/diagrammatics/#QInchworm.diagrammatics.get_topologies_at_order","page":"QInchworm.diagrammatics","title":"QInchworm.diagrammatics.get_topologies_at_order","text":"get_topologies_at_order(\n    order::Int64\n) -> Vector{QInchworm.diagrammatics.Topology}\nget_topologies_at_order(\n    order::Int64,\n    k;\n    with_external_arc\n) -> Vector{QInchworm.diagrammatics.Topology}\n\n\nReturn topologies of a given order. If k is specified, then only the doubly k-connected topologies are returned. With with_external_arc set to true parity of the returned topologies is computed as if an extra arc overarching the last 2order - k vertices was present.\n\n\n\n\n\n","category":"function"},{"location":"modules/expansion/#QInchworm.expansion","page":"QInchworm.expansion","title":"QInchworm.expansion","text":"","category":"section"},{"location":"modules/expansion/","page":"QInchworm.expansion","title":"QInchworm.expansion","text":"CurrentModule = QInchworm.expansion","category":"page"},{"location":"modules/expansion/","page":"QInchworm.expansion","title":"QInchworm.expansion","text":"AllPPGFSectorTypes\nAllPPGFTypes\nset_bold_ppgf!\nset_bold_ppgf_at_order!","category":"page"},{"location":"modules/expansion/#QInchworm.expansion.AllPPGFSectorTypes","page":"QInchworm.expansion","title":"QInchworm.expansion.AllPPGFSectorTypes","text":"Supported container types for a single block of an atomic propagator (PPGF)\n\n\n\n\n\n","category":"type"},{"location":"modules/expansion/#QInchworm.expansion.AllPPGFTypes","page":"QInchworm.expansion","title":"QInchworm.expansion.AllPPGFTypes","text":"Supported container types for a full atomic propagator (PPGF)\n\n\n\n\n\n","category":"type"},{"location":"modules/expansion/#QInchworm.expansion.set_bold_ppgf!","page":"QInchworm.expansion","title":"QInchworm.expansion.set_bold_ppgf!","text":"set_bold_ppgf!(\n    expansion::QInchworm.expansion.Expansion{ScalarGF<:Keldysh.AbstractTimeGF{ComplexF64, true}, Vector{QInchworm.spline_gf.IncSplineImaginaryTimeGF{ComplexF64, false}}},\n    τ_i::Keldysh.TimeGridPoint,\n    τ_f::Keldysh.TimeGridPoint,\n    val::Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}\n)\n\n\nSet the value of expansion.P corresponding to a given pair of imaginary time points (tau_f tau_i). This method is defined for the spline-interpolated imaginary-time propagators.\n\nParameters\n\nexpansion: Pseudo-particle expansion.\nτ_i:       Initial imaginary time tau_i.\nτ_f:       Final imaginary time tau_f.\nval:       Block matrix to set P(tau_f tau_i) to.\n\n\n\n\n\nset_bold_ppgf!(\n    expansion::QInchworm.expansion.Expansion,\n    t_i::Keldysh.TimeGridPoint,\n    t_f::Keldysh.TimeGridPoint,\n    val::Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}\n)\n\n\nSet the value of expansion.P corresponding to a given pair of contour time points (t_f t_i).\n\nParameters\n\nexpansion: Pseudo-particle expansion.\nt_i:       Initial imaginary time t_i.\nt_f:       Final imaginary time t_f.\nval:       Block matrix to set P(t_f t_i) to.\n\n\n\n\n\n","category":"function"},{"location":"modules/expansion/#QInchworm.expansion.set_bold_ppgf_at_order!","page":"QInchworm.expansion","title":"QInchworm.expansion.set_bold_ppgf_at_order!","text":"set_bold_ppgf_at_order!(\n    expansion::QInchworm.expansion.Expansion{ScalarGF<:Keldysh.AbstractTimeGF{ComplexF64, true}, Vector{QInchworm.spline_gf.IncSplineImaginaryTimeGF{ComplexF64, false}}},\n    order::Integer,\n    τ_i::Keldysh.TimeGridPoint,\n    τ_f::Keldysh.TimeGridPoint,\n    val::Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}\n)\n\n\nSet the value of expansion.P_orders corresponding to a given expansion order and to a pair of imaginary time points (tau_f tau_i). This method is defined for the spline-interpolated imaginary-time propagators.\n\nParameters\n\nexpansion: Pseudo-particle expansion.\norder:     Expansion order.\nτ_i:       Initial imaginary time tau_i.\nτ_f:       Final imaginary time tau_f.\nval:       Block matrix to set P(tau_f tau_i) to.\n\n\n\n\n\nset_bold_ppgf_at_order!(\n    expansion::QInchworm.expansion.Expansion,\n    order::Integer,\n    t_i::Keldysh.TimeGridPoint,\n    t_f::Keldysh.TimeGridPoint,\n    val::Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}\n)\n\n\nSet the value of expansion.P_orders corresponding to a given expansion order and to a pair of contour time points (t_f t_i).\n\nParameters\n\nexpansion: Pseudo-particle expansion.\norder:     Expansion order.\nt_i:       Initial imaginary time t_i.\nt_f:       Final imaginary time t_f.\nval:       Block matrix to set P(t_f t_i) to.\n\n\n\n\n\n","category":"function"},{"location":"modules/qmc_integrate/#QInchworm.qmc_integrate","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate","text":"","category":"section"},{"location":"modules/qmc_integrate/","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate","text":"CurrentModule = QInchworm.qmc_integrate","category":"page"},{"location":"modules/qmc_integrate/","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate","text":"qmc_integrate","category":"page"},{"location":"modules/qmc_integrate/#QInchworm.qmc_integrate","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate","text":"Quasi Monte Carlo integration routines.\n\nConcepts and notation used here are introduced in\n\nQuantum Quasi-Monte Carlo Technique for Many-Body Perturbative Expansions\nM. Maček, P. T. Dumitrescu, C. Bertrand, B.Triggs, O. Parcollet, and X. Waintal\nPhys. Rev. Lett. 125, 047702 (2020)\n\nIntegration domain transformations Sort and Root are defined in\n\nTransforming low-discrepancy sequences from a cube to a simplex\nT. Pillards and R. Cools\nJ. Comput. Appl. Math. 174, 29 (2005)\n\n\n\n\n\n","category":"module"},{"location":"modules/qmc_integrate/#Model-functions-and-domain-transformations","page":"QInchworm.qmc_integrate","title":"Model functions and domain transformations","text":"","category":"section"},{"location":"modules/qmc_integrate/","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate","text":"make_model_function\nmake_exp_model_function\nmake_exp_trans\nexp_p_norm","category":"page"},{"location":"modules/qmc_integrate/#QInchworm.qmc_integrate.make_model_function","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate.make_model_function","text":"make_model_function(\n    c::Keldysh.AbstractContour,\n    t_f::Keldysh.BranchPoint,\n    h::Vector\n) -> QInchworm.qmc_integrate.var\"#1#3\"\n\n\nMake the model function p_d(mathbfu) = prod_i=1^d h_i(u_i-1 - u_i) out of a list of functions h_i(v).\n\nu_0 is the distance measured along the time contour c to the point t_f.\n\n\n\n\n\n","category":"function"},{"location":"modules/qmc_integrate/#QInchworm.qmc_integrate.make_exp_model_function","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate.make_exp_model_function","text":"make_exp_model_function(\n    c::Keldysh.AbstractContour,\n    t_f::Keldysh.BranchPoint,\n    τ::Real,\n    d::Int64\n) -> QInchworm.qmc_integrate.var\"#5#6\"\n\n\nMake the model function p_d(mathbfu) = prod_i=1^d h(u_i-1 - u_i) out of an exponential function h(v) = e^-vtau.\n\nu_0 is the distance measured along the time contour c to the point t_f.\n\n\n\n\n\n","category":"function"},{"location":"modules/qmc_integrate/#QInchworm.qmc_integrate.make_exp_trans","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate.make_exp_trans","text":"make_exp_trans(\n    c::Keldysh.AbstractContour,\n    t_f::Keldysh.BranchPoint,\n    τ::Real\n) -> QInchworm.qmc_integrate.var\"#7#8\"\n\n\nMake a transformation from the unit hypercube mathbfxin0 1^d to a d-dimensional simplex u_f  u_1  u_2  ldots  u_d-1  u_d  -infty induced by the model function p_d(mathbfu) = prod_i=1^d e^(u_i-1 - u_i)tau.\n\nThe target variables u_i are reference values of time points measured as distances along the contour c. u_0 is the distance to the point t_f.\n\n\n\n\n\n","category":"function"},{"location":"modules/qmc_integrate/#QInchworm.qmc_integrate.exp_p_norm","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate.exp_p_norm","text":"exp_p_norm(τ::Real, d::Int64) -> Real\n\n\nNorm of the model function p_d(mathbfu) = prod_i=1^d e^(u_i-1 - u_i)tau.\n\n\n\n\n\n","category":"function"},{"location":"modules/qmc_integrate/#Quasi-Monte-Carlo-integration","page":"QInchworm.qmc_integrate","title":"Quasi Monte Carlo integration","text":"","category":"section"},{"location":"modules/qmc_integrate/","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate","text":"qmc_integral\nqmc_integral_n_samples\nqmc_time_ordered_integral\nqmc_time_ordered_integral_n_samples\nqmc_time_ordered_integral_sort\nqmc_time_ordered_integral_root\nqmc_inchworm_integral_root","category":"page"},{"location":"modules/qmc_integrate/#QInchworm.qmc_integrate.qmc_integral","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate.qmc_integral","text":"qmc_integral(f)\nqmc_integral(f, init; p, p_norm, trans, seq, N)\n\n\nQuasi Monte Carlo integration with warping.\n\nParameters\n\nf:      Integrand.\ninit:   Initial (zero) value of the integral.\np:      Positive model function p_d(mathbfu).\np_norm: Integral of p_d(mathbfu) over the mathbfu-domain.\ntrans:  Transformation from mathbfxin0 1^d onto the mathbfu-domain.\nseq:    Quasi-random sequence generator.\nN:      The number of points to be taken from the quasi-random sequence.\n\nReturns\n\nValue of the integral.\n\n\n\n\n\n","category":"function"},{"location":"modules/qmc_integrate/#QInchworm.qmc_integrate.qmc_integral_n_samples","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate.qmc_integral_n_samples","text":"qmc_integral_n_samples(f)\nqmc_integral_n_samples(\n    f,\n    init;\n    p,\n    p_norm,\n    trans,\n    seq,\n    N_samples\n)\n\n\nQuasi Monte Carlo integration with warping.\n\nThis function takes a specified number of valid (non-nothing) samples of the integrand.\n\nParameters\n\nf:         Integrand.\ninit:      Initial (zero) value of the integral.\np:         Positive model function p_d(mathbfu).\np_norm:    Integral of p_d(mathbfu) over the mathbfu-domain.\ntrans:     Transformation from mathbfxin0 1^d onto the              mathbfu-domain.\nseq:       Quasi-random sequence generator.\nN_samples: The number of samples to be taken.\n\nReturns\n\nValue of the integral.\n\n\n\n\n\n","category":"function"},{"location":"modules/qmc_integrate/#QInchworm.qmc_integrate.qmc_time_ordered_integral","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate.qmc_time_ordered_integral","text":"qmc_time_ordered_integral(\n    f,\n    d::Int64,\n    c::Keldysh.AbstractContour,\n    t_i::Keldysh.BranchPoint,\n    t_f::Keldysh.BranchPoint;\n    init,\n    seq,\n    τ,\n    N\n)\n\n\nEvaluate a d-dimensional contour-ordered integral of a function f(mathbft),\n\n    int_t_i^t_f dt_1 int_t_i^t_1 dt_2 ldots int_t_i^t_d-1 dt_d\n     f(t_1 t_2 ldots t_d)\n\nusing the Sobol sequence for quasi-random sampling and the exponential model function p_d(mathbft) = prod_i=1^d e^(t_i-1 - t_i)tau.\n\nParameters\n\nf:    Integrand.\nd:    Dimensionality of the integral.\nc:    Time contour to integrate over.\nt_i:  Starting time point on the contour.\nt_f:  Final time point on the contour.\ninit: Initial (zero) value of the integral.\nseq:  Quasi-random sequence generator.\nτ:    Decay parameter of the exponential model function.\nN:    The number of points to be taken from the quasi-random sequence.\n\nReturns\n\nValue of the integral.\n\n\n\n\n\n","category":"function"},{"location":"modules/qmc_integrate/#QInchworm.qmc_integrate.qmc_time_ordered_integral_n_samples","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate.qmc_time_ordered_integral_n_samples","text":"qmc_time_ordered_integral_n_samples(\n    f,\n    d::Int64,\n    c::Keldysh.AbstractContour,\n    t_i::Keldysh.BranchPoint,\n    t_f::Keldysh.BranchPoint;\n    init,\n    seq,\n    τ,\n    N_samples\n)\n\n\nEvaluate a d-dimensional contour-ordered integral of a function f(mathbft),\n\n    int_t_i^t_f dt_1 int_t_i^t_1 dt_2 ldots int_t_i^t_d-1 dt_d\n     f(t_1 t_2 ldots t_d)\n\nusing the Sobol sequence for quasi-random sampling and the exponential model function p_d(mathbft) = prod_i=1^d e^(t_i-1 - t_i)tau.\n\nThis function evaluates the integrand a specified number of times while discarding any transformed sequence points that fall outside the integration domain.\n\nParameters\n\nf:         Integrand.\nd:         Dimensionality of the integral.\nc:         Time contour to integrate over.\nt_i:       Starting time point on the contour.\nt_f:       Final time point on the contour.\ninit:      Initial (zero) value of the integral.\nseq:       Quasi-random sequence generator.\nτ:         Decay parameter of the exponential model function.\nN_samples: The number of samples to be taken.\n\nReturns\n\nValue of the integral.\n\n\n\n\n\n","category":"function"},{"location":"modules/qmc_integrate/#QInchworm.qmc_integrate.qmc_time_ordered_integral_sort","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate.qmc_time_ordered_integral_sort","text":"qmc_time_ordered_integral_sort(\n    f,\n    d::Int64,\n    c::Keldysh.AbstractContour,\n    t_i::Keldysh.BranchPoint,\n    t_f::Keldysh.BranchPoint;\n    init,\n    seq,\n    N\n)\n\n\nEvaluate a d-dimensional contour-ordered integral of a function f(mathbft),\n\n    int_t_i^t_f dt_1 int_t_i^t_1 dt_2 ldots int_t_i^t_d-1 dt_d\n     f(t_1 t_2 ldots t_d)\n\nusing the Sobol sequence for quasi-random sampling and the 'Sort' transform.\n\nParameters\n\nf:    Integrand.\nd:    Dimensionality of the integral.\nc:    Time contour to integrate over.\nt_i:  Starting time point on the contour.\nt_f:  Final time point on the contour.\ninit: Initial (zero) value of the integral.\nseq:  Quasi-random sequence generator.\nN:    The number of points to be taken from the quasi-random sequence.\n\nReturns\n\nValue of the integral.\n\n\n\n\n\n","category":"function"},{"location":"modules/qmc_integrate/#QInchworm.qmc_integrate.qmc_time_ordered_integral_root","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate.qmc_time_ordered_integral_root","text":"qmc_time_ordered_integral_root(\n    f,\n    d::Int64,\n    c::Keldysh.AbstractContour,\n    t_i::Keldysh.BranchPoint,\n    t_f::Keldysh.BranchPoint;\n    init,\n    seq,\n    N\n)\n\n\nEvaluate a d-dimensional contour-ordered integral of a function f(mathbft),\n\n    int_t_i^t_f dt_1 int_t_i^t_1 dt_2 ldots int_t_i^t_d-1 dt_d\n     f(t_1 t_2 ldots t_d)\n\nusing the Sobol sequence for quasi-random sampling and the 'Root' transform.\n\nParameters\n\nf:    Integrand.\nd:    Dimensionality of the integral.\nc:    Time contour to integrate over.\nt_i:  Starting time point on the contour.\nt_f:  Final time point on the contour.\ninit: Initial (zero) value of the integral.\nseq:  Quasi-random sequence generator.\nN:    The number of points to be taken from the quasi-random sequence.\n\nReturns\n\nValue of the integral.\n\n\n\n\n\n","category":"function"},{"location":"modules/qmc_integrate/#QInchworm.qmc_integrate.qmc_inchworm_integral_root","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate.qmc_inchworm_integral_root","text":"qmc_inchworm_integral_root(\n    f,\n    d_before::Int64,\n    d_after::Int64,\n    c::Keldysh.AbstractContour,\n    t_i::Keldysh.BranchPoint,\n    t_w::Keldysh.BranchPoint,\n    t_f::Keldysh.BranchPoint;\n    init,\n    seq,\n    N\n)\n\n\nEvaluate an inchworm-type contour-ordered integral of a function f(mathbft),\n\nint_t_w^t_f dt_1\nint_t_w^t_1 dt_2 ldots\nint_t_w^t_d_after-1 dt_d_after\nint_t_i^t_w dt_d_after+1 ldots\nint_t_i^t_d-2 dt_d-1\nint_t_i^t_d-1 dt_d\n    f(t_1 t_2 ldots t_d)\n\nusing the Sobol sequence for quasi-random sampling and a two-piece 'Root' transform. The total dimension of the domain d is the sum of the amounts of integration variables in the 'before' (d_textbefore) and the after (d_textafter) components.\n\nParameters\n\nf:        Integrand.\nd_before: Dimensionality of the before-t_w component of the integration domain.\nd_after:  Dimensionality of the after-t_w component of the integration domain.\nc:        Time contour to integrate over.\nt_i:      Starting time point on the contour.\nt_w:      'Worm' time point on the contour separating the 'before' and 'after' parts.\nt_f:      Final time point on the contour.\ninit:     Initial (zero) value of the integral.\nseq:      Quasi-random sequence generator.\nN:        The number of samples to be taken.\n\nReturns\n\nValue of the integral.\n\n\n\n\n\n","category":"function"},{"location":"modules/qmc_integrate/#Miscellaneous","page":"QInchworm.qmc_integrate","title":"Miscellaneous","text":"","category":"section"},{"location":"modules/qmc_integrate/","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate","text":"branch_direction\ncontour_function_return_type","category":"page"},{"location":"modules/qmc_integrate/#QInchworm.qmc_integrate.branch_direction","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate.branch_direction","text":"Dictionary mapping branches of the Keldysh contour to their unitary direction coefficients in the complex time plane.\n\n\n\n\n\n","category":"constant"},{"location":"modules/qmc_integrate/#QInchworm.qmc_integrate.contour_function_return_type","page":"QInchworm.qmc_integrate","title":"QInchworm.qmc_integrate.contour_function_return_type","text":"contour_function_return_type(f::Function) -> Any\n\n\nDetect the return type of a function applied to a vector of Keldysh.BranchPoint.\n\n\n\n\n\n","category":"function"},{"location":"about/#About-QInchworm.jl","page":"About","title":"About QInchworm.jl","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"QInchworm.jl is developed by Igor Krivenko, Hugo U. R. Strand and Joseph Kleinhenz and is distributed under the terms of the GNU General Public License version 3 or later.","category":"page"},{"location":"about/","page":"About","title":"About","text":"We acknowledge funding from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (Grant agreement No. 854843-FASTCORR).","category":"page"},{"location":"about/","page":"About","title":"About","text":"Large scale testing and benchmarking were enabled by resources from the National Academic Infrastructure for Supercomputing in Sweden (NAISS) and the Swedish National Infrastructure for Computing (SNIC) through the projects SNIC 2022/1-18, SNIC 2022/6-113, SNIC 2022/13-9, SNIC 2022/21-15, NAISS 2023/1-44, and NAISS 2023/6-129 at PDC, NSC and CSC partially funded by the Swedish Research Council through grant agreements no. 2022-06725 and no. 2018-05973.","category":"page"},{"location":"api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"QInchworm","category":"page"},{"location":"api/#QInchworm","page":"Public API","title":"QInchworm","text":"A quasi Monte Carlo inchworm impurity solver for multi-orbital fermionic models.\n\n\n\n\n\n","category":"module"},{"location":"api/#api:QInchworm.expansion","page":"Public API","title":"QInchworm.expansion","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"CurrentModule = QInchworm.expansion","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"expansion","category":"page"},{"location":"api/#QInchworm.expansion","page":"Public API","title":"QInchworm.expansion","text":"Strong coupling pseudo-particle expansion problem.\n\nExports\n\nExpansion\nInteractionPair\nadd_corr_operators!\n\n\n\n\n\n","category":"module"},{"location":"api/","page":"Public API","title":"Public API","text":"Expansion\nExpansion(::ked.EDCore,\n          ::kd.AbstractTimeGrid,\n          ::Vector{InteractionPair{ScalarGF}};\n          ::Vector{Tuple{Operator, Operator}},\n          interpolate_ppgf) where ScalarGF\nExpansion(::op.OperatorExpr,\n          ::ked.SetOfIndices,\n          ::kd.ImaginaryTimeGrid;\n          ::kd.ImaginaryTimeGF{ComplexF64, false},\n          ::Union{Keldysh.ImaginaryTimeGF{Float64, false}, Nothing},\n          ::Vector{Tuple{Operator, Operator}},\n          interpolate_ppgf)\nInteractionPair\nadd_corr_operators!","category":"page"},{"location":"api/#QInchworm.expansion.Expansion","page":"Public API","title":"QInchworm.expansion.Expansion","text":"struct Expansion{ScalarGF<:Keldysh.AbstractTimeGF{ComplexF64, true}, PPGF<:Union{Vector{Keldysh.GenericTimeGF{ComplexF64, false, Keldysh.FullTimeGrid}}, Vector{Keldysh.ImaginaryTimeGF{ComplexF64, false}}, Vector{QInchworm.spline_gf.IncSplineImaginaryTimeGF{ComplexF64, false}}, Vector{QInchworm.spline_gf.SplineInterpolatedGF{Keldysh.GenericTimeGF{ComplexF64, false, Keldysh.FullTimeGrid}, ComplexF64, false}}, Vector{QInchworm.spline_gf.SplineInterpolatedGF{Keldysh.ImaginaryTimeGF{ComplexF64, false}, ComplexF64, false}}}}\n\nThe Expansion structure contains the components needed to define a strong coupling pseudo-particle expansion problem.\n\nFields\n\ned: Exact diagonalization solver for the local degrees of freedom\nP0: Non-interacting propagator (pseudo-particle Green's function)\nP: Interacting propagator (pseudo-particle Green's function)\nP_orders: Contributions to interacting propagators, per expansion diagram order\npairs: List of pseudo-particle interactions\ndeterminants: List of hybridization function determinants (not implemented yet)\ncorr_operators: List of operator pairs used in accumulation of two-point correlation functions\nidentity_mat: Block matrix representation of the identity operator\npair_operator_mat: Block matrix representation of paired operators (operator_i, operator_f)\ncorr_operators_mat: Block matrix representation of corr_operators\nsubspace_attachable_pairs: Given a subspace index s_i, lists indices of all interaction pairs with operator_i acting non-trivially on that subspace.\n\n\n\n\n\n","category":"type"},{"location":"api/#QInchworm.expansion.Expansion-Union{Tuple{ScalarGF}, Tuple{KeldyshED.EDCore, Keldysh.AbstractTimeGrid, Array{QInchworm.expansion.InteractionPair{ScalarGF}, 1}}} where ScalarGF","page":"Public API","title":"QInchworm.expansion.Expansion","text":"Expansion(\n    ed::KeldyshED.EDCore,\n    grid::Keldysh.AbstractTimeGrid,\n    interaction_pairs::Array{QInchworm.expansion.InteractionPair{ScalarGF}, 1};\n    corr_operators,\n    interpolate_ppgf\n) -> QInchworm.expansion.Expansion\n\n\nParameters\n\ned:                Exact diagonalization solution of the local problem.\ngrid:              Contour time grid to define the local propagators on.\ninteraction_pairs: The list of pair interactions to expand in.\ncorr_operators:    The list of operator pairs used in accumulation of two-point                      correlation functions.\ninterpolate_ppgf:  Use a quadratic spline interpolation to represent and evaluate                      the local propagators. Currently works only with the imaginary                      time propagators.\n\n\n\n\n\n","category":"method"},{"location":"api/#QInchworm.expansion.Expansion-Tuple{KeldyshED.Operators.OperatorExpr, KeldyshED.Hilbert.SetOfIndices, Keldysh.ImaginaryTimeGrid}","page":"Public API","title":"QInchworm.expansion.Expansion","text":"Expansion(\n    hamiltonian::KeldyshED.Operators.OperatorExpr,\n    soi::KeldyshED.Hilbert.SetOfIndices,\n    grid::Keldysh.ImaginaryTimeGrid;\n    hybridization,\n    nn_interaction,\n    corr_operators,\n    interpolate_ppgf\n)\n\n\nA higher-level constructor of Expansion that solves the local problem defined by a Hamiltonian and internally generates a list of pseudo-particle pair interactions from hybridization and nn-interaction functions.\n\nParameters\n\nhamiltonian:      Hamiltonian of the local problem.\nsoi:              An ordered set of indices carried by creation/annihilation operators                     of the local problem.\ngrid:             Imaginary time grid to define the local propagators on.\nhybridization:    A matrix-valued hybridization function Delta_ij(tau). A                     correspondence between the matrix elements (i j) and operators                     c^dagger_i c_j is established by soi.\nnn_interaction:   A matrix-valued nn-interaction function U_ij(tau).                     A correspondence between the matrix elements (i j) and operators                     n_i n_j is established by soi.\ncorr_operators:   The list of operator pairs used in accumulation of two-point                     correlation functions.\ninterpolate_ppgf: Use a quadratic spline interpolation to represent and evaluate                     the local propagators.\n\n\n\n\n\n","category":"method"},{"location":"api/#QInchworm.expansion.InteractionPair","page":"Public API","title":"QInchworm.expansion.InteractionPair","text":"struct InteractionPair{ScalarGF<:Keldysh.AbstractTimeGF{ComplexF64, true}}\n\nData type for pseudo-particle interactions containing two operators and one scalar propagator.\n\nIndexed access to the operators stored in a pair::InteractionPair is supported: pair[1] and pair[2] are equivalent to pair.operator_i and pair.operator_f respectively.\n\nFields\n\noperator_f::KeldyshED.Operators.RealOperatorExpr: Final time operator\noperator_i::KeldyshED.Operators.RealOperatorExpr: Initial time operator\npropagator::Keldysh.AbstractTimeGF{ComplexF64, true}: Scalar propagator\n\n\n\n\n\n","category":"type"},{"location":"api/#QInchworm.expansion.add_corr_operators!","page":"Public API","title":"QInchworm.expansion.add_corr_operators!","text":"add_corr_operators!(\n    expansion::QInchworm.expansion.Expansion,\n    ops::Tuple{KeldyshED.Operators.RealOperatorExpr, KeldyshED.Operators.RealOperatorExpr}\n)\n\n\nAdd a pair of operators (A B) used to measure the two-point correlator langle A(t_1) B(t_2)rangle to expansion.\n\nParameters\n\nexpansion: Pseudo-particle expansion.\nops:       The pair of operators (A B).\n\n\n\n\n\n","category":"function"},{"location":"api/#api:QInchworm.inchworm","page":"Public API","title":"QInchworm.inchworm","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"CurrentModule = QInchworm.inchworm","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"inchworm","category":"page"},{"location":"api/#QInchworm.inchworm","page":"Public API","title":"QInchworm.inchworm","text":"High level functions implementing the quasi Monte Carlo inchworm algorithm.\n\nExports\n\ncorrelator_2p\ninchworm!\n\n\n\n\n\n","category":"module"},{"location":"api/","page":"Public API","title":"Public API","text":"inchworm!\ncorrelator_2p","category":"page"},{"location":"api/#QInchworm.inchworm.inchworm!","page":"Public API","title":"QInchworm.inchworm.inchworm!","text":"inchworm!(\n    expansion::QInchworm.expansion.Expansion,\n    grid::Keldysh.ImaginaryTimeGrid,\n    orders,\n    orders_bare,\n    N_samples::Int64;\n    n_pts_after_max\n)\n\n\nPerform a complete qMC inchworm calculation of the bold propagators on the imaginary time segment. Results of the calculation are written into expansion.P.\n\nParameters\n\nexpansion:       Strong coupling expansion problem.\ngrid:            Imaginary time grid of the bold propagators.\norders:          List of expansion orders to be accounted for during a regular                    inchworm step.\norders_bare:     List of expansion orders to be accounted for during the initial                    inchworm step.\nN_samples:       Number of samples to be used in qMC integration. Must be a power of 2.\nn_pts_after_max: Maximum number of points in the after-tau_w region to be taken                    into account. By default, diagrams with all valid numbers of the                    after-tau_w points are considered.\n\n\n\n\n\n","category":"function"},{"location":"api/#QInchworm.inchworm.correlator_2p","page":"Public API","title":"QInchworm.inchworm.correlator_2p","text":"correlator_2p(\n    expansion::QInchworm.expansion.Expansion,\n    grid::Keldysh.ImaginaryTimeGrid,\n    A_B_pair_idx::Int64,\n    τ::Keldysh.TimeGridPoint,\n    top_data::Vector{QInchworm.inchworm.TopologiesInputData};\n    tmr\n) -> ComplexF64\n\n\nCalculate value of a two-point correlator langle A(tau) B(0)rangle for one value of the imaginary time argument tau. The pair of operators (A B) used in the calculation is taken from expansion.corr_operators[A_B_pair_idx].\n\nParameters\n\nexpansion:    Strong coupling expansion problem. expansion.P must contain precomputed                 bold propagators.\ngrid:         Imaginary time grid of the correlator to be computed.\nA_B_pair_idx: Index of the (A B) pair within expansion.corr_operators.\nτ:            The imaginary time argument tau.\ntop_data:     Accumulation input data.\ntmr:          A TimerOutput object used for profiling.\n\nReturns\n\nAccumulated value of the two-point correlator.\n\n\n\n\n\ncorrelator_2p(\n    expansion::QInchworm.expansion.Expansion,\n    grid::Keldysh.ImaginaryTimeGrid,\n    orders,\n    N_samples::Int64\n) -> Vector\n\n\nCalculate a two-point correlator langle A(tau) B(0)rangle on the imaginary time segment. Accumulation is performed for each pair of operators (A B) in expansion.corr_operators. Only the operators that are a single monomial in cc^dagger are supported.\n\nParameters\n\nexpansion: Strong coupling expansion problem. expansion.P must contain precomputed              bold propagators.\ngrid:      Imaginary time grid of the correlator to be computed.\norders:    List of expansion orders to be accounted for.\nN_samples: Number of samples to be used in qMC integration. Must be a power of 2.\n\nReturns\n\nA list of scalar-valued GF objects containing the computed correlators, one element per a pair in expansion.corr_operators.\n\n\n\n\n\n","category":"function"},{"location":"api/#api:QInchworm.ppgf","page":"Public API","title":"QInchworm.ppgf","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"CurrentModule = QInchworm.ppgf","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"ppgf","category":"page"},{"location":"api/#QInchworm.ppgf","page":"Public API","title":"QInchworm.ppgf","text":"Pseudo-particle Green's functions (propagators) of finite fermionic systems and related tools.\n\nFor a system defined by a time-independent Hamiltonian hat H, the pseudo-particle Green's function (PPGF) is\n\nP(z z) = left\nbeginarrayll\n-i (-1)^hat N e^-i hat H(z-z) z succ -ibeta cap -ibeta succeq z\n-i e^-i hat H(z-z) textotherwise\nendarray\nright\n\nIn particular, on the imaginary time segment alone one has P(tau) = -i e^-hat H tau.\n\nThis operator has a block-diagonal structure determined by the symmetry sectors of hat H, and is stored as a vector of GF containers corresponding to the individual diagonal blocks (FullTimePPGF, ImaginaryTimePPGF).\n\nExports\n\nFullTimePPGF\nImaginaryTimePPGF\natomic_ppgf\ndensity_matrix\nnormalize!\npartition_function\n\n\n\n\n\n","category":"module"},{"location":"api/","page":"Public API","title":"Public API","text":"FullTimePPGF\nImaginaryTimePPGF\natomic_ppgf\npartition_function\ndensity_matrix\nnormalize!","category":"page"},{"location":"api/#QInchworm.ppgf.FullTimePPGF","page":"Public API","title":"QInchworm.ppgf.FullTimePPGF","text":"An atomic propagator (PPGF) defined on a full Keldysh contour\n\n\n\n\n\n","category":"type"},{"location":"api/#QInchworm.ppgf.ImaginaryTimePPGF","page":"Public API","title":"QInchworm.ppgf.ImaginaryTimePPGF","text":"An atomic propagator (PPGF) defined on an imaginary time segment\n\n\n\n\n\n","category":"type"},{"location":"api/#QInchworm.ppgf.atomic_ppgf","page":"Public API","title":"QInchworm.ppgf.atomic_ppgf","text":"atomic_ppgf(\n    grid::Keldysh.FullTimeGrid,\n    ed::KeldyshED.EDCore\n) -> Vector{Keldysh.GenericTimeGF{ComplexF64, false, Keldysh.FullTimeGrid}}\n\n\nCompute atomic pseudo-particle Green's function on a full contour time grid for a time-independent exact diagonalization problem ed.\n\nAs the resulting PPGF P(z z) is defined up to a multiplier e^-ilambda (z-z), we choose the energy shift lambda to fulfil the normalization property mathrmTri P(-ibeta 0) = 1.\n\n\n\n\n\natomic_ppgf(\n    grid::Keldysh.ImaginaryTimeGrid,\n    ed::KeldyshED.EDCore\n) -> Vector{Keldysh.ImaginaryTimeGF{ComplexF64, false}}\n\n\nCompute atomic pseudo-particle Green's function on an imaginary time grid for a time-independent exact diagonalization problem ed.\n\nAs the resulting PPGF P(tau) is defined up to a multiplier e^-lambdatau, we choose the energy shift lambda to fulfil the normalization property mathrmTri P(beta) = 1.\n\n\n\n\n\n","category":"function"},{"location":"api/#QInchworm.ppgf.partition_function","page":"Public API","title":"QInchworm.ppgf.partition_function","text":"partition_function(\n    P::Vector{<:Keldysh.AbstractTimeGF}\n) -> ComplexF64\n\n\nExtract the partition function Z = mathrmTri P(-ibeta 0) from a un-normalized pseudo-particle Green's function P.\n\n\n\n\n\n","category":"function"},{"location":"api/#QInchworm.ppgf.density_matrix","page":"Public API","title":"QInchworm.ppgf.density_matrix","text":"density_matrix(P::Vector{<:Keldysh.AbstractTimeGF}) -> Any\n\n\nExtract the equilibrium density matrix rho = i P(-ibeta 0) from a normalized pseudo-particle Green's function P. The density matrix is block-diagonal and is returned as a vector of blocks.\n\n\n\n\n\n","category":"function"},{"location":"api/#QInchworm.ppgf.normalize!","page":"Public API","title":"QInchworm.ppgf.normalize!","text":"normalize!(P::Vector{<:Keldysh.AbstractTimeGF}, β) -> Any\n\n\nNormalize a pseudo-particle Green's function P by multiplying it by e^-ilambda (z-z) with lambda chosen such that mathrmTri P(-ibeta 0) = 1.\n\nReturns\n\nThe energy shift lambda.\n\n\n\n\n\nnormalize!(P_s::Keldysh.AbstractTimeGF, λ)\n\n\nMultiply a given diagonal block of a pseudo-particle Green's function P_s by e^-ilambda (z-z).\n\n\n\n\n\n","category":"function"},{"location":"api/#api:QInchworm.spline_gf","page":"Public API","title":"QInchworm.spline_gf","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"CurrentModule = QInchworm.spline_gf","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"spline_gf","category":"page"},{"location":"api/#QInchworm.spline_gf","page":"Public API","title":"QInchworm.spline_gf","text":"Spline-interpolated Green's function containers.\n\nExports\n\nSplineInterpolatedGF\nph_conj\n\n\n\n\n\n","category":"module"},{"location":"api/","page":"Public API","title":"Public API","text":"SplineInterpolatedGF\nSplineInterpolatedGF(::GFType; ::kd.TimeGridPoint) where {\n        T <: Number, scalar, GFType <: kd.AbstractTimeGF{T, scalar}}","category":"page"},{"location":"api/#QInchworm.spline_gf.SplineInterpolatedGF","page":"Public API","title":"QInchworm.spline_gf.SplineInterpolatedGF","text":"struct SplineInterpolatedGF{GFType, T, scalar} <: Keldysh.AbstractTimeGF{T, scalar}\n\nWrapper around a Green's function object that allows for fast cubic spline interpolation on the time grid.\n\nThe wrapper supports square bracket access to the wrapped object, direct access to the grid property, eltype(), Keldysh.norbitals() and Keldysh.TimeDomain(). Evaluation at an arbitrary contour time point (via operator ()) is carried out by a stored set of pre-computed B-spline interpolants.\n\nFields\n\nGF::Any: Wrapped Green's function\ninterpolants::Any: B-spline interpolants, one object per matrix element of G\n\n\n\n\n\n","category":"type"},{"location":"api/#QInchworm.spline_gf.SplineInterpolatedGF-Union{Tuple{GFType}, Tuple{scalar}, Tuple{T}} where {T<:Number, scalar, GFType<:Keldysh.AbstractTimeGF{T, scalar}}","page":"Public API","title":"QInchworm.spline_gf.SplineInterpolatedGF","text":"SplineInterpolatedGF(\n    GF::Keldysh.AbstractTimeGF{T<:Number, scalar};\n    τ_max\n) -> QInchworm.spline_gf.SplineInterpolatedGF\n\n\nMake a SplineInterpolatedGF wrapper around GF and compute interpolants of its data from the start of the grid up to τ_max. By default, the entire data array is used.\n\n\n\n\n\n","category":"method"},{"location":"api/#api:QInchworm.utility","page":"Public API","title":"QInchworm.utility","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"CurrentModule = QInchworm.utility","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"utility","category":"page"},{"location":"api/#QInchworm.utility","page":"Public API","title":"QInchworm.utility","text":"An assorted collection of utility types and functions.\n\nExports\n\nph_conj\n\n\n\n\n\n","category":"module"},{"location":"api/","page":"Public API","title":"Public API","text":"ph_conj","category":"page"},{"location":"api/#QInchworm.utility.ph_conj","page":"Public API","title":"QInchworm.utility.ph_conj","text":"ph_conj(\n    G_int::QInchworm.spline_gf.SplineInterpolatedGF{GFType<:Keldysh.ImaginaryTimeGF{T<:Number, true}, T<:Number, true}\n)\n\n\nGiven a spline-interpolated scalar-valued imaginary time Green's function g(tau), return its particle-hole conjugate g(beta-tau).\n\n\n\n\n\nph_conj(g::Keldysh.ImaginaryTimeGF{T, true}) -> Any\n\n\nGiven a scalar-valued imaginary time Green's function g(tau), return its particle-hole conjugate g(beta-tau).\n\n\n\n\n\n","category":"function"},{"location":"modules/inchworm/#QInchworm.inchworm","page":"QInchworm.inchworm","title":"QInchworm.inchworm","text":"","category":"section"},{"location":"modules/inchworm/","page":"QInchworm.inchworm","title":"QInchworm.inchworm","text":"CurrentModule = QInchworm.inchworm","category":"page"},{"location":"modules/inchworm/","page":"QInchworm.inchworm","title":"QInchworm.inchworm","text":"TopologiesInputData\ninchworm_step\ninchworm_step_bare","category":"page"},{"location":"modules/inchworm/#QInchworm.inchworm.TopologiesInputData","page":"QInchworm.inchworm","title":"QInchworm.inchworm.TopologiesInputData","text":"struct TopologiesInputData\n\nInchworm algorithm input data specific to a given set of topologies.\n\nFields\n\norder::Int64: Expansion order\nn_pts_after::Int64: Number of points in the after-t_w region\ntopologies::Vector{QInchworm.diagrammatics.Topology}: List of contributing topologies\nN_samples::Int64: Numbers of qMC samples (must be a power of 2)\n\n\n\n\n\n","category":"type"},{"location":"modules/inchworm/#QInchworm.inchworm.inchworm_step","page":"QInchworm.inchworm","title":"QInchworm.inchworm.inchworm_step","text":"inchworm_step(\n    expansion::QInchworm.expansion.Expansion,\n    c::Keldysh.AbstractContour,\n    τ_i::Keldysh.TimeGridPoint,\n    τ_w::Keldysh.TimeGridPoint,\n    τ_f::Keldysh.TimeGridPoint,\n    top_data::Vector{QInchworm.inchworm.TopologiesInputData};\n    tmr\n) -> Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}\n\n\nPerform one regular step of qMC inchworm accumulation of the bold propagators.\n\nParameters\n\nexpansion: Strong coupling expansion problem.\nc:         Time contour for integration.\nτ_i:       Initial time of the bold propagator to be computed.\nτ_w:       Inchworm splitting time tau_w.\nτ_f:       Final time of the bold propagator to be computed.\ntop_data:  Inchworm algorithm input data.\ntmr:       A TimerOutput object used for profiling.\n\nReturns\n\nAccumulated value of the bold propagator.\n\n\n\n\n\n","category":"function"},{"location":"modules/inchworm/#QInchworm.inchworm.inchworm_step_bare","page":"QInchworm.inchworm","title":"QInchworm.inchworm.inchworm_step_bare","text":"inchworm_step_bare(\n    expansion::QInchworm.expansion.Expansion,\n    c::Keldysh.AbstractContour,\n    τ_i::Keldysh.TimeGridPoint,\n    τ_f::Keldysh.TimeGridPoint,\n    top_data::Vector{QInchworm.inchworm.TopologiesInputData};\n    tmr\n) -> Any\n\n\nPerform the initial step of qMC inchworm accumulation of the bold propagators. This step amounts to summing all (not only inchworm-proper) diagrams built out of the bare propagators.\n\nParameters\n\nexpansion: Strong coupling expansion problem.\nc:         Time contour for integration.\nτ_i:       Initial time of the bold propagator to be computed.\nτ_f:       Final time of the bold propagator to be computed.\ntop_data:  Inchworm algorithm input data.\ntmr:       A TimerOutput object used for profiling.\n\nReturns\n\nAccumulated value of the bold propagator.\n\n\n\n\n\n","category":"function"},{"location":"modules/mpi/#QInchworm.mpi","page":"QInchworm.mpi","title":"QInchworm.mpi","text":"","category":"section"},{"location":"modules/mpi/","page":"QInchworm.mpi","title":"QInchworm.mpi","text":"CurrentModule = QInchworm.mpi","category":"page"},{"location":"modules/mpi/","page":"QInchworm.mpi","title":"QInchworm.mpi","text":"mpi\nismaster\nrank_sub_range\nall_gather(::Vector{T}; ::MPI.Comm) where T\nall_reduce!(::SectorBlockMatrix, op; ::MPI.Comm)","category":"page"},{"location":"modules/mpi/#QInchworm.mpi","page":"QInchworm.mpi","title":"QInchworm.mpi","text":"MPI-related utility functions.\n\n\n\n\n\n","category":"module"},{"location":"modules/mpi/#QInchworm.mpi.ismaster","page":"QInchworm.mpi","title":"QInchworm.mpi.ismaster","text":"ismaster() -> Bool\nismaster(comm::MPI.Comm) -> Bool\n\n\nCheck whether the calling process has the rank 0 within the group associated with the communicator comm.\n\n\n\n\n\n","category":"function"},{"location":"modules/mpi/#QInchworm.mpi.rank_sub_range","page":"QInchworm.mpi","title":"QInchworm.mpi.rank_sub_range","text":"rank_sub_range(N::Integer; comm) -> UnitRange{Int64}\n\n\nSplit the range 1:N between MPI processes in the communicator comm as evenly as possible and return the sub-range 'owned' by the calling process.\n\n\n\n\n\n","category":"function"},{"location":"modules/mpi/#QInchworm.mpi.all_gather-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"QInchworm.mpi","title":"QInchworm.mpi.all_gather","text":"all_gather(subvec::Array{T, 1}; comm) -> Vector\n\n\nPerform the MPI collective operation Allgather for vectors of elements of a generic type T.\n\nParameters\n\nsubvec: Subvector to be gathered.\ncomm:   MPI communicator.\n\nReturns\n\nThe gathered vector of the same element type T.\n\n\n\n\n\n","category":"method"},{"location":"modules/mpi/#QInchworm.mpi.all_reduce!-Tuple{Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}, Any}","page":"QInchworm.mpi","title":"QInchworm.mpi.all_reduce!","text":"all_reduce!(\n    sbm::Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}},\n    op;\n    comm\n)\n\n\nPerform the in-place MPI collective operation Allreduce for a sector block matrix.\n\nParameters\n\nsbm:  Sector block matrices to be reduced.\nop:   Reduction operation.\ncomm: MPI communicator.\n\nReturns\n\nThe gathered vector of the same element type T.\n\n\n\n\n\n","category":"method"},{"location":"modules/spline_gf/#QInchworm.spline_gf","page":"QInchworm.spline_gf","title":"QInchworm.spline_gf","text":"","category":"section"},{"location":"modules/spline_gf/","page":"QInchworm.spline_gf","title":"QInchworm.spline_gf","text":"CurrentModule = QInchworm.spline_gf","category":"page"},{"location":"modules/spline_gf/#SplineInterpolatedGF","page":"QInchworm.spline_gf","title":"SplineInterpolatedGF","text":"","category":"section"},{"location":"modules/spline_gf/","page":"QInchworm.spline_gf","title":"QInchworm.spline_gf","text":"make_interpolant(::kd.ImaginaryTimeGF{T, scalar}, k, l, ::kd.TimeGridPoint) where {\n    T <: Number, scalar}\nupdate_interpolant!(::SplineInterpolatedGF{kd.ImaginaryTimeGF{T, scalar}, T, scalar},\n                    k, l; ::kd.TimeGridPoint) where {T <: Number, scalar}\nupdate_interpolants!(::SplineInterpolatedGF{kd.ImaginaryTimeGF{T, scalar}, T, scalar};\n                     ::kd.TimeGridPoint) where {T <: Number, scalar}\ninterpolate(::SplineInterpolatedGF{kd.ImaginaryTimeGF{T, true}, T, true},\n            ::kd.BranchPoint, ::kd.BranchPoint) where T\ninterpolate(::SplineInterpolatedGF{kd.ImaginaryTimeGF{T, false}, T, false},\n            ::kd.BranchPoint, ::kd.BranchPoint) where T","category":"page"},{"location":"modules/spline_gf/#QInchworm.spline_gf.make_interpolant-Union{Tuple{scalar}, Tuple{T}, Tuple{Keldysh.ImaginaryTimeGF{T, scalar}, Any, Any, Keldysh.TimeGridPoint}} where {T<:Number, scalar}","page":"QInchworm.spline_gf","title":"QInchworm.spline_gf.make_interpolant","text":"make_interpolant(\n    GF::Keldysh.ImaginaryTimeGF{T<:Number, scalar},\n    k,\n    l,\n    τ_max::Keldysh.TimeGridPoint\n) -> Interpolations.ScaledInterpolation{_A, 1, _B, Interpolations.BSpline{Interpolations.Cubic{Interpolations.Line{Interpolations.OnGrid}}}} where {_A, _B}\n\n\nMake a cubic B-spline interpolant from GF's data corresponding to its matrix indices k, l. Data points from the start of the grid up to τ_max are used.\n\n\n\n\n\n","category":"method"},{"location":"modules/spline_gf/#QInchworm.spline_gf.update_interpolant!-Union{Tuple{scalar}, Tuple{T}, Tuple{QInchworm.spline_gf.SplineInterpolatedGF{Keldysh.ImaginaryTimeGF{T, scalar}, T, scalar}, Any, Any}} where {T<:Number, scalar}","page":"QInchworm.spline_gf","title":"QInchworm.spline_gf.update_interpolant!","text":"update_interpolant!(\n    G_int::QInchworm.spline_gf.SplineInterpolatedGF{Keldysh.ImaginaryTimeGF{T<:Number, scalar}, T<:Number, scalar},\n    k,\n    l;\n    τ_max\n) -> Interpolations.ScaledInterpolation{_A, 1, _B, Interpolations.BSpline{Interpolations.Cubic{Interpolations.Line{Interpolations.OnGrid}}}} where {_A, _B}\n\n\nUpdate the interpolant stored in G_int and corresponding to its matrix indices k, l. The updated interpolant interpolates data points of G_int.GF from the start of the grid up to τ_max. By default, the entire data array is used.\n\n\n\n\n\n","category":"method"},{"location":"modules/spline_gf/#QInchworm.spline_gf.update_interpolants!-Union{Tuple{QInchworm.spline_gf.SplineInterpolatedGF{Keldysh.ImaginaryTimeGF{T, scalar}, T, scalar}}, Tuple{scalar}, Tuple{T}} where {T<:Number, scalar}","page":"QInchworm.spline_gf","title":"QInchworm.spline_gf.update_interpolants!","text":"update_interpolants!(\n    G_int::QInchworm.spline_gf.SplineInterpolatedGF{Keldysh.ImaginaryTimeGF{T<:Number, scalar}, T<:Number, scalar};\n    τ_max\n)\n\n\nUpdate all interpolants stored in G_int. The updated interpolants interpolate data points of G_int.GF from the start of the grid up to τ_max. By default, the entire data array is used.\n\n\n\n\n\n","category":"method"},{"location":"modules/spline_gf/#Interpolations.interpolate-Union{Tuple{T}, Tuple{QInchworm.spline_gf.SplineInterpolatedGF{Keldysh.ImaginaryTimeGF{T, true}, T, true}, Keldysh.BranchPoint, Keldysh.BranchPoint}} where T","page":"QInchworm.spline_gf","title":"Interpolations.interpolate","text":"interpolate(\n    G_int::QInchworm.spline_gf.SplineInterpolatedGF{Keldysh.ImaginaryTimeGF{T, true}, T, true},\n    t1::Keldysh.BranchPoint,\n    t2::Keldysh.BranchPoint\n) -> Any\n\n\nEvaluate the spline-interpolated Green's function G_int at the contour time arguments t1, t2.\n\n\n\n\n\n","category":"method"},{"location":"modules/spline_gf/#Interpolations.interpolate-Union{Tuple{T}, Tuple{QInchworm.spline_gf.SplineInterpolatedGF{Keldysh.ImaginaryTimeGF{T, false}, T, false}, Keldysh.BranchPoint, Keldysh.BranchPoint}} where T","page":"QInchworm.spline_gf","title":"Interpolations.interpolate","text":"interpolate(\n    G_int::QInchworm.spline_gf.SplineInterpolatedGF{Keldysh.ImaginaryTimeGF{T, false}, T, false},\n    t1::Keldysh.BranchPoint,\n    t2::Keldysh.BranchPoint\n) -> Any\n\n\nEvaluate the spline-interpolated Green's function G_int at the contour time arguments t1, t2.\n\n\n\n\n\n","category":"method"},{"location":"modules/spline_gf/#IncSplineImaginaryTimeGF","page":"QInchworm.spline_gf","title":"IncSplineImaginaryTimeGF","text":"","category":"section"},{"location":"modules/spline_gf/","page":"QInchworm.spline_gf","title":"QInchworm.spline_gf","text":"IncSplineImaginaryTimeGF\nIncSplineImaginaryTimeGF(::kd.ImaginaryTimeGF{T, true}, ::T) where {T <: Number}\nIncSplineImaginaryTimeGF(::kd.ImaginaryTimeGF{T, false}, ::Matrix{T}) where {T <: Number}\nmake_inc_interpolant(::kd.ImaginaryTimeGF{T, scalar}, k, l, ::T) where {T <: Number, scalar}\nBase.zero(::IncSplineImaginaryTimeGF{T, false}) where {T <: Number}\nBase.zero(::IncSplineImaginaryTimeGF{T, true}) where {T <: Number}\nextend!(::IncSplineImaginaryTimeGF, val)\ninterpolate(::IncSplineImaginaryTimeGF{T, true}, ::kd.BranchPoint, ::kd.BranchPoint) where T\ninterpolate(::IncSplineImaginaryTimeGF{T, false}, ::kd.BranchPoint, ::kd.BranchPoint) where T","category":"page"},{"location":"modules/spline_gf/#QInchworm.spline_gf.IncSplineImaginaryTimeGF","page":"QInchworm.spline_gf","title":"QInchworm.spline_gf.IncSplineImaginaryTimeGF","text":"struct IncSplineImaginaryTimeGF{T, scalar} <: Keldysh.AbstractTimeGF{T, scalar}\n\nWrapper around an imaginary time Green's function object that supports interpolation based on the IncrementalSpline.\n\nThe wrapper supports square bracket access to the wrapped object, direct access to the grid property, eltype(), Keldysh.norbitals() and Keldysh.TimeDomain(). Evaluation at an arbitrary imaginary time point (via operator ()) is carried out by a stored set of pre-computed IncrementalSpline interpolants.\n\nFields\n\nGF::Keldysh.ImaginaryTimeGF: Wrapped Green's function\ninterpolants::Any: Incremental spline interpolants, one object per matrix element of GF\n\n\n\n\n\n","category":"type"},{"location":"modules/spline_gf/#QInchworm.spline_gf.IncSplineImaginaryTimeGF-Union{Tuple{T}, Tuple{Keldysh.ImaginaryTimeGF{T, true}, T}} where T<:Number","page":"QInchworm.spline_gf","title":"QInchworm.spline_gf.IncSplineImaginaryTimeGF","text":"IncSplineImaginaryTimeGF(\n    GF::Keldysh.ImaginaryTimeGF{T<:Number, true},\n    derivative_at_0::Number\n) -> QInchworm.spline_gf.IncSplineImaginaryTimeGF{_A, true} where _A\n\n\nMake a IncSplineImaginaryTimeGF wrapper around a scalar-valued GF and initialize incremental interpolants of its data. derivative_at_0 is imaginary time derivative of GF at tau=0 needed to compute the first segment of the interpolants.\n\n\n\n\n\n","category":"method"},{"location":"modules/spline_gf/#QInchworm.spline_gf.IncSplineImaginaryTimeGF-Union{Tuple{T}, Tuple{Keldysh.ImaginaryTimeGF{T, false}, Matrix{T}}} where T<:Number","page":"QInchworm.spline_gf","title":"QInchworm.spline_gf.IncSplineImaginaryTimeGF","text":"IncSplineImaginaryTimeGF(\n    GF::Keldysh.ImaginaryTimeGF{T<:Number, false},\n    derivative_at_0::Array{T<:Number, 2}\n) -> QInchworm.spline_gf.IncSplineImaginaryTimeGF{_A, false} where _A\n\n\nMake a IncSplineImaginaryTimeGF wrapper around a matrix-valued GF and initialize incremental interpolants of its data. derivative_at_0 is imaginary time derivative of GF at tau=0 needed to compute the first segment of the interpolants.\n\n\n\n\n\n","category":"method"},{"location":"modules/spline_gf/#QInchworm.spline_gf.make_inc_interpolant-Union{Tuple{scalar}, Tuple{T}, Tuple{Keldysh.ImaginaryTimeGF{T, scalar}, Any, Any, T}} where {T<:Number, scalar}","page":"QInchworm.spline_gf","title":"QInchworm.spline_gf.make_inc_interpolant","text":"make_inc_interpolant(\n    GF::Keldysh.ImaginaryTimeGF{T<:Number, scalar},\n    k,\n    l,\n    derivative_at_0::Number\n) -> QInchworm.utility.IncrementalSpline\n\n\nMake an incremental spline interpolant from GF's data and corresponding to its matrix indices k, l. derivative_at_0 is imaginary time derivative of GF[k, l] at tau=0 needed to compute the first segment of the interpolant.\n\n\n\n\n\n","category":"method"},{"location":"modules/spline_gf/#Base.zero-Union{Tuple{QInchworm.spline_gf.IncSplineImaginaryTimeGF{T, false}}, Tuple{T}} where T<:Number","page":"QInchworm.spline_gf","title":"Base.zero","text":"zero(\n    G_int::QInchworm.spline_gf.IncSplineImaginaryTimeGF{T<:Number, false}\n) -> QInchworm.spline_gf.IncSplineImaginaryTimeGF\n\n\nMake a zero matrix-valued IncSplineImaginaryTimeGF object similar to G_int.\n\n\n\n\n\n","category":"method"},{"location":"modules/spline_gf/#Base.zero-Union{Tuple{QInchworm.spline_gf.IncSplineImaginaryTimeGF{T, true}}, Tuple{T}} where T<:Number","page":"QInchworm.spline_gf","title":"Base.zero","text":"zero(\n    G_int::QInchworm.spline_gf.IncSplineImaginaryTimeGF{T<:Number, true}\n) -> QInchworm.spline_gf.IncSplineImaginaryTimeGF\n\n\nMake a zero scalar-valued IncSplineImaginaryTimeGF object similar to G_int.\n\n\n\n\n\n","category":"method"},{"location":"modules/spline_gf/#QInchworm.utility.extend!-Tuple{QInchworm.spline_gf.IncSplineImaginaryTimeGF, Any}","page":"QInchworm.spline_gf","title":"QInchworm.utility.extend!","text":"extend!(\n    G_int::QInchworm.spline_gf.IncSplineImaginaryTimeGF,\n    val\n) -> Any\n\n\nExtend the underlying IncrementalSpline objects stored in G_int with a value val.\n\n\n\n\n\n","category":"method"},{"location":"modules/spline_gf/#Interpolations.interpolate-Union{Tuple{T}, Tuple{QInchworm.spline_gf.IncSplineImaginaryTimeGF{T, true}, Keldysh.BranchPoint, Keldysh.BranchPoint}} where T","page":"QInchworm.spline_gf","title":"Interpolations.interpolate","text":"interpolate(\n    G_int::QInchworm.spline_gf.IncSplineImaginaryTimeGF{T, true},\n    τ1::Keldysh.BranchPoint,\n    τ2::Keldysh.BranchPoint\n) -> Any\n\n\nEvaluate the spline-interpolated scalar-valued Green's function G_int at the imaginary time arguments τ1, τ2.\n\n\n\n\n\n","category":"method"},{"location":"modules/spline_gf/#Interpolations.interpolate-Union{Tuple{T}, Tuple{QInchworm.spline_gf.IncSplineImaginaryTimeGF{T, false}, Keldysh.BranchPoint, Keldysh.BranchPoint}} where T","page":"QInchworm.spline_gf","title":"Interpolations.interpolate","text":"interpolate(\n    G_int::QInchworm.spline_gf.IncSplineImaginaryTimeGF{T, false},\n    τ1::Keldysh.BranchPoint,\n    τ2::Keldysh.BranchPoint\n) -> Any\n\n\nEvaluate the spline-interpolated matrix-valued Green's function G_int at the imaginary time arguments τ1, τ2.\n\n\n\n\n\n","category":"method"},{"location":"modules/ppgf/#QInchworm.ppgf","page":"QInchworm.ppgf","title":"QInchworm.ppgf","text":"","category":"section"},{"location":"modules/ppgf/","page":"QInchworm.ppgf","title":"QInchworm.ppgf","text":"CurrentModule = QInchworm.ppgf","category":"page"},{"location":"modules/ppgf/#Operators-and-their-matrices","page":"QInchworm.ppgf","title":"Operators and their matrices","text":"","category":"section"},{"location":"modules/ppgf/","page":"QInchworm.ppgf","title":"QInchworm.ppgf","text":"total_density_operator\noperator_matrix_representation\noperator_product","category":"page"},{"location":"modules/ppgf/#QInchworm.ppgf.total_density_operator","page":"QInchworm.ppgf","title":"QInchworm.ppgf.total_density_operator","text":"total_density_operator(ed::KeldyshED.EDCore) -> Any\n\n\nReturn the total density operator hat N = sum_i n_i, where i labels all single-particle basis states used to construct the exact diagonalization object ed.\n\n\n\n\n\n","category":"function"},{"location":"modules/ppgf/#QInchworm.ppgf.operator_matrix_representation","page":"QInchworm.ppgf","title":"QInchworm.ppgf.operator_matrix_representation","text":"operator_matrix_representation(\n    op_expr::KeldyshED.Operators.OperatorExpr{S<:Number},\n    ed::KeldyshED.EDCore\n) -> Vector\n\n\nMake matrix representation of an operator expression op_expr in each invariant subspace (symmetry sector) defined by the exact diagonalization object ed.\n\nNB! Requires that the operator expression does not mix symmetry sectors.\n\n\n\n\n\n","category":"function"},{"location":"modules/ppgf/#QInchworm.ppgf.operator_product","page":"QInchworm.ppgf","title":"QInchworm.ppgf.operator_product","text":"operator_product(\n    ed::KeldyshED.EDCore,\n    P,\n    s_i::Integer,\n    z_i,\n    z_f,\n    vertices\n) -> Tuple{Any, Any}\n\n\nEvaluate a product of vertices at different contour times z_n n=1ldots N with the pseudo-particle Green's functions sandwiched in between. The product is padded with the PPGFs P(z_1 z_i) and P(z_f z_N) at the respective ends of the contour segment z_i z_f.\n\nvertices is a contour-time ordered list of triples (z_n, c_n, o_n) were:\n\nz_n is a contour time,\nc_n is +1/-1 for creation/annihilation operator respectively, and\no_n is a spin-orbital index.\n\nParameters\n\ned:       An object defining the exact diagonalization problem.\nP:        The pseudo-particle Green's function as a list of its diagonal blocks.\ns_i:      Initial symmetry sector, in which the rightmost PPGF is acting.\nz_i:      Initial contour time z_i.\nz_f:      Final contour time z_f.\nvertices: The list of vertices.\n\nReturns\n\nThe evaluated matrix product and the final symmetry sector, in which the leftmost PPGF is acting.\n\n\n\n\n\n","category":"function"},{"location":"modules/ppgf/#Pseudo-particle-Green's-functions","page":"QInchworm.ppgf","title":"Pseudo-particle Green's functions","text":"","category":"section"},{"location":"modules/ppgf/","page":"QInchworm.ppgf","title":"QInchworm.ppgf","text":"FullTimePPGFSector\nImaginaryTimePPGFSector\natomic_ppgf!\nfirst_order_spgf\nfirst_order_spgf!\ncheck_ppgf_real_time_symmetries\nset_ppgf_initial_conditions!\nppgf_real_time_initial_conditions!\nset_ppgf_symmetric!\ninitial_ppgf_derivative\nreduced_ppgf","category":"page"},{"location":"modules/ppgf/#QInchworm.ppgf.FullTimePPGFSector","page":"QInchworm.ppgf","title":"QInchworm.ppgf.FullTimePPGFSector","text":"A single block of an atomic propagator (PPGF) defined on a full Keldysh contour\n\n\n\n\n\n","category":"type"},{"location":"modules/ppgf/#QInchworm.ppgf.ImaginaryTimePPGFSector","page":"QInchworm.ppgf","title":"QInchworm.ppgf.ImaginaryTimePPGFSector","text":"A single block of an atomic propagator (PPGF) defined on an imaginary time segment\n\n\n\n\n\n","category":"type"},{"location":"modules/ppgf/#QInchworm.ppgf.atomic_ppgf!","page":"QInchworm.ppgf","title":"QInchworm.ppgf.atomic_ppgf!","text":"atomic_ppgf!(P::Vector, ed::KeldyshED.EDCore; Δλ)\n\n\nIn-place version of atomic_ppgf() that writes the computed PPGF into its first argument P. If Δλ is non-zero, then P(z z) is multiplied by e^-iDeltalambda (z-z).\n\n\n\n\n\n","category":"function"},{"location":"modules/ppgf/#QInchworm.ppgf.first_order_spgf","page":"QInchworm.ppgf","title":"QInchworm.ppgf.first_order_spgf","text":"first_order_spgf(\n    P::Vector{Keldysh.GenericTimeGF{ComplexF64, false, Keldysh.FullTimeGrid}},\n    ed::KeldyshED.EDCore,\n    o1,\n    o2\n) -> Any\n\n\nCompute the first order pseudo-particle diagram contribution to the single-particle Green's function g_o_1 o_2(z z) defined on the full Keldysh contour.\n\nParameters\n\nP:  Pseudo-particle Green's function.\ned: An object defining the exact diagonalization problem.\no1: First index of the single-particle Green's function to be computed.\no2: Second index of the single-particle Green's function to be computed.\n\nReturns\n\nThe computed single-particle Green's function.\n\n\n\n\n\nfirst_order_spgf(\n    P::Vector{Keldysh.ImaginaryTimeGF{ComplexF64, false}},\n    ed::KeldyshED.EDCore,\n    o1,\n    o2\n) -> Any\n\n\nCompute the first order pseudo-particle diagram contribution to the single-particle Green's function g_o_1 o_2(tau) defined on the imaginary time segment.\n\nParameters\n\nP:  Pseudo-particle Green's function.\ned: An object defining the exact diagonalization problem.\no1: First index of the single-particle Green's function to be computed.\no2: Second index of the single-particle Green's function to be computed.\n\nReturns\n\nThe computed single-particle Green's function.\n\n\n\n\n\n","category":"function"},{"location":"modules/ppgf/#QInchworm.ppgf.first_order_spgf!","page":"QInchworm.ppgf","title":"QInchworm.ppgf.first_order_spgf!","text":"first_order_spgf!(g, P, ed::KeldyshED.EDCore, o1, o2)\n\n\nIn-place version of first_order_spgf() that writes the computed single-particle Green's function into its first argument g.\n\n\n\n\n\n","category":"function"},{"location":"modules/ppgf/#QInchworm.ppgf.check_ppgf_real_time_symmetries","page":"QInchworm.ppgf","title":"QInchworm.ppgf.check_ppgf_real_time_symmetries","text":"check_ppgf_real_time_symmetries(\n    P::Vector{Keldysh.GenericTimeGF{ComplexF64, false, Keldysh.FullTimeGrid}},\n    ed::KeldyshED.EDCore\n) -> Bool\n\n\nCheck whether a given pseudo-particle Green's function P obeys all symmetry relations between its Keldysh components.\n\nParameters\n\nP:  Pseudo-particle Green's function to check.\ned: An object defining the respective exact diagonalization problem.\n\n\n\n\n\n","category":"function"},{"location":"modules/ppgf/#QInchworm.ppgf.set_ppgf_initial_conditions!","page":"QInchworm.ppgf","title":"QInchworm.ppgf.set_ppgf_initial_conditions!","text":"set_ppgf_initial_conditions!(\n    P::Union{Vector{Keldysh.GenericTimeGF{ComplexF64, false, Keldysh.FullTimeGrid}}, Vector{Keldysh.ImaginaryTimeGF{ComplexF64, false}}}\n)\n\n\nGiven a pseudo-particle Green's function P, set its values to zero except for the same-time components P(z z) = -i.\n\n\n\n\n\n","category":"function"},{"location":"modules/ppgf/#QInchworm.ppgf.ppgf_real_time_initial_conditions!","page":"QInchworm.ppgf","title":"QInchworm.ppgf.ppgf_real_time_initial_conditions!","text":"ppgf_real_time_initial_conditions!(\n    P::Vector{Keldysh.GenericTimeGF{ComplexF64, false, Keldysh.FullTimeGrid}},\n    ed::KeldyshED.EDCore\n)\n\n\nGiven a pseudo-particle Green's function P, set its values at the real branch edges t = 0 to be consistent with values on the imaginary time branch.\n\nParameters\n\nP:  Pseudo-particle Green's function.\ned: Exact diagonalization object used to derive statistical sign pre-factors of PPGF       sectors.\n\n\n\n\n\n","category":"function"},{"location":"modules/ppgf/#QInchworm.ppgf.set_ppgf_symmetric!","page":"QInchworm.ppgf","title":"QInchworm.ppgf.set_ppgf_symmetric!","text":"set_ppgf_symmetric!(\n    P_s::Keldysh.GenericTimeGF{ComplexF64, false, Keldysh.FullTimeGrid},\n    n,\n    z1::Keldysh.TimeGridPoint,\n    z2::Keldysh.TimeGridPoint,\n    value\n) -> Any\n\n\nSet real-time pseudo-particle Green's function symmetry connected time pairs.\n\nParameters\n\nP_s:   Diagonal block of the PPGF to be updated.\nn:     The number of particles in the corresponding sector.\nz1:    First argument of the PPGF.\nz2:    Second argument of the PPGF (must lie on the backward branch).\nvalue: Value to set elements of the PPGF to.\n\n\n\n\n\n","category":"function"},{"location":"modules/ppgf/#QInchworm.ppgf.initial_ppgf_derivative","page":"QInchworm.ppgf","title":"QInchworm.ppgf.initial_ppgf_derivative","text":"initial_ppgf_derivative(\n    ed::KeldyshED.EDCore,\n    β::Float64\n) -> Vector{Any}\n\n\nCompute the imaginary time derivative of the atomic pseudo-particle Green's function, partial_tau P(tau) at tau=0.\n\nParameters\n\ned: Exact diagonalization object defining the atomic propagator.\nβ:  Inverse temperature.\n\nReturns\n\nValue of the derivative as a block-diagonal matrix (a list of blocks).\n\n\n\n\n\n","category":"function"},{"location":"modules/ppgf/#QInchworm.ppgf.reduced_ppgf","page":"QInchworm.ppgf","title":"QInchworm.ppgf.reduced_ppgf","text":"reduced_ppgf(\n    P::Vector{<:Keldysh.AbstractTimeGF},\n    ed::KeldyshED.EDCore,\n    target_soi::KeldyshED.Hilbert.SetOfIndices\n) -> Any\n\n\nTake a partial trace of a pseudo-particle Green's function.\n\nParameters\n\nP:          Pseudo-particle Green's function.\ned:         Exact diagonalization object compatible with P.\ntarget_soi: A subset of creation/annihilation operator labels defining the target               subsystem, in which the reduced PPGF acts.\n\nReturns\n\nThe reduced PPGF written in the Fock state basis of the target subsystem.\n\n\n\n\n\n","category":"function"},{"location":"modules/topology_eval/#QInchworm.topology_eval","page":"QInchworm.topology_eval","title":"QInchworm.topology_eval","text":"","category":"section"},{"location":"modules/topology_eval/","page":"QInchworm.topology_eval","title":"QInchworm.topology_eval","text":"CurrentModule = QInchworm.topology_eval","category":"page"},{"location":"modules/topology_eval/","page":"QInchworm.topology_eval","title":"QInchworm.topology_eval","text":"topology_eval\nNodeKind\nNode\nFixedNode\nIdentityNode\nInchNode\nOperatorNode\nTopologyEvaluator\nTopologyEvaluator(::Expansion, ::Int, ::Dict{Int, FixedNode}; ::TimerOutput)\neval(::Topology, ::Vector{kd.BranchPoint})\neval(::Vector{Topology}, ::Vector{kd.BranchPoint})\n_traverse_configuration_tree!","category":"page"},{"location":"modules/topology_eval/#QInchworm.topology_eval","page":"QInchworm.topology_eval","title":"QInchworm.topology_eval","text":"Evaluator for strong-coupling expansion diagrams of a specific topology.\n\n\n\n\n\n","category":"module"},{"location":"modules/topology_eval/#QInchworm.topology_eval.NodeKind","page":"QInchworm.topology_eval","title":"QInchworm.topology_eval.NodeKind","text":"primitive type NodeKind <: Enum{Int32} 32\n\nNode kind classification using @enum.\n\nPossible values: pair_flag, identity_flag, inch_flag, operator_flag.\n\n\n\n\n\n","category":"type"},{"location":"modules/topology_eval/#QInchworm.topology_eval.Node","page":"QInchworm.topology_eval","title":"QInchworm.topology_eval.Node","text":"struct Node\n\nNode in the atomic propagator backbone of a strong-coupling diagram.\n\nFields\n\nkind::QInchworm.topology_eval.NodeKind: Kind of the node\narc_index::Int64: Index for pair interaction arc\noperator_index::Int64: Index of operator\n\n\n\n\n\n","category":"type"},{"location":"modules/topology_eval/#QInchworm.topology_eval.FixedNode","page":"QInchworm.topology_eval","title":"QInchworm.topology_eval.FixedNode","text":"struct FixedNode\n\nNode in the atomic propagator backbone of a strong-coupling diagram fixed at a certain contour time point.\n\nFields\n\nnode::QInchworm.topology_eval.Node: Reference to operator\ntime::Keldysh.BranchPoint: Contour time point\n\n\n\n\n\n","category":"type"},{"location":"modules/topology_eval/#QInchworm.topology_eval.IdentityNode","page":"QInchworm.topology_eval","title":"QInchworm.topology_eval.IdentityNode","text":"IdentityNode(\n    time::Keldysh.BranchPoint\n) -> QInchworm.topology_eval.FixedNode\n\n\nReturn a fixed node at time time with an associated identity operator.\n\n\n\n\n\n","category":"function"},{"location":"modules/topology_eval/#QInchworm.topology_eval.InchNode","page":"QInchworm.topology_eval","title":"QInchworm.topology_eval.InchNode","text":"InchNode(\n    time::Keldysh.BranchPoint\n) -> QInchworm.topology_eval.FixedNode\n\n\nReturn a fixed 'inch' node at time time with an associated identity operator.\n\n\n\n\n\n","category":"function"},{"location":"modules/topology_eval/#QInchworm.topology_eval.OperatorNode","page":"QInchworm.topology_eval","title":"QInchworm.topology_eval.OperatorNode","text":"OperatorNode(\n    time::Keldysh.BranchPoint,\n    operator_pair_index::Int64,\n    operator_index::Int64\n) -> QInchworm.topology_eval.FixedNode\n\n\nReturn a fixed operator node at time time with an associated operator. The actual operator is stored in an Expansion structure and is uniquely identified by the pair (operator_pair_index, operator_index).\n\n\n\n\n\n","category":"function"},{"location":"modules/topology_eval/#QInchworm.topology_eval.TopologyEvaluator","page":"QInchworm.topology_eval","title":"QInchworm.topology_eval.TopologyEvaluator","text":"struct TopologyEvaluator\n\nThe evaluation engine for the strong-coupling expansion diagrams.\n\nIn the following, a sequence of Node's contributing to a diagram of a certain topology is referred to as 'configuration'.\n\nFields\n\nexp::QInchworm.expansion.Expansion: Pseudo-particle expansion problem\nconf::Vector{QInchworm.topology_eval.Node}: Configuration as a list of nodes arranged in the contour order\ntimes::Vector{Keldysh.BranchPoint}: Contour positions of nodes in the configuration\ntop_to_conf_pos::Vector{Int64}: Correspondence of node positions within a topology and a configuration\nuse_bold_prop::Bool: Must the bold PPGFs be used?\nppgf_mats::Matrix{Matrix{ComplexF64}}: PPGFs evaluated at all relevant pairs of time arguments. ppgf_mats[i, s] is the s-th diagonal block of exp.P (or exp.P0) evaluated at the pair of time points (t_i+1 t_i).\n\npair_ints::Matrix{ComplexF64}: Pair interaction arcs evaluated at all relevant pairs of time arguments.\npair_ints[a, p] is the propagator from exp.pairs[p] evaluated at the pair of time points corresponding to the a-th arc in a topology.\n\nselected_pair_ints::Vector{Int64}: Indices of pair interactions within exp.pairs assigned to each interaction arc in a topology.\n\ntop_result_mats::Vector{Matrix{ComplexF64}}: Pre-allocated container for per-topology evaluation results\nmatrix_prod::QInchworm.utility.LazyMatrixProduct{ComplexF64}: Pre-allocated matrix product evaluator\ntmr::TimerOutputs.TimerOutput: Internal performance timer\n\n\n\n\n\n","category":"type"},{"location":"modules/topology_eval/#QInchworm.topology_eval.TopologyEvaluator-Tuple{QInchworm.expansion.Expansion, Int64, Dict{Int64, QInchworm.topology_eval.FixedNode}}","page":"QInchworm.topology_eval","title":"QInchworm.topology_eval.TopologyEvaluator","text":"TopologyEvaluator(\n    exp::QInchworm.expansion.Expansion,\n    order::Int64,\n    fixed_nodes::Dict{Int64, QInchworm.topology_eval.FixedNode};\n    tmr\n) -> QInchworm.topology_eval.TopologyEvaluator\n\n\nParameters\n\nexp: Strong-coupling expansion problem.\norder: Expansion order of the diagrams.\nfixed_nodes: List of fixed nodes in a configuration along with their positions.\ntmr: Internal performance timer.\n\n\n\n\n\n","category":"method"},{"location":"modules/topology_eval/#QInchworm.topology_eval._traverse_configuration_tree!","page":"QInchworm.topology_eval","title":"QInchworm.topology_eval._traverse_configuration_tree!","text":"_traverse_configuration_tree!(\n    eval::QInchworm.topology_eval.TopologyEvaluator,\n    pos::Int64,\n    s_i::Int64,\n    s_f::Int64,\n    pair_int_weight::ComplexF64\n)\n\n\nRecursively traverse a tree of all configurations stemming from a given topology and contributing to the quantity of interest. The result is accumulated in eval.top_result_mats.\n\nParameters\n\neval:            Evaluator object.\npos:             Position of the currently processed Node in the                    configuration.\ns_i:             Left block index of the matrix representation of the current node.\ns_f:             Right block index expected at the final node.\npair_int_weight: Current weight of the pair interaction contribution.\n\n\n\n\n\n","category":"function"},{"location":"modules/utility/#QInchworm.utility","page":"QInchworm.utility","title":"QInchworm.utility","text":"","category":"section"},{"location":"modules/utility/","page":"QInchworm.utility","title":"QInchworm.utility","text":"CurrentModule = QInchworm.utility","category":"page"},{"location":"modules/utility/#Interpolations.jl-addon:-Neumann-boundary-conditions-for-the-cubic-spline","page":"QInchworm.utility","title":"Interpolations.jl addon: Neumann boundary conditions for the cubic spline","text":"","category":"section"},{"location":"modules/utility/","page":"QInchworm.utility","title":"QInchworm.utility","text":"NeumannBC\nInterpolations.prefiltering_system(::Type{T},\n                                   ::Type{TC},\n                                   ::Int,\n                                   ::Interpolations.Cubic{BC}) where {\n                                    T, TC, BC <: NeumannBC{Interpolations.OnGrid}}","category":"page"},{"location":"modules/utility/#QInchworm.utility.NeumannBC","page":"QInchworm.utility","title":"QInchworm.utility.NeumannBC","text":"struct NeumannBC{GT<:Union{Nothing, Interpolations.GridType}, T<:Number} <: Interpolations.BoundaryCondition\n\nInterpolations.jl addon: Implementation of the Neumann boundary conditions for the cubic spline.\n\nFields\n\ngt::Union{Nothing, Interpolations.GridType}: Grid type\nleft_derivative::Number: Function derivative at the left boundary\nright_derivative::Number: Function derivative at the right boundary\n\n\n\n\n\n","category":"type"},{"location":"modules/utility/#Interpolations.prefiltering_system-Union{Tuple{BC}, Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Interpolations.Cubic{BC}}} where {T, TC, BC<:(QInchworm.utility.NeumannBC{Interpolations.OnGrid})}","page":"QInchworm.utility","title":"Interpolations.prefiltering_system","text":"prefiltering_system(\n    _::Type{T},\n    _::Type{TC},\n    n::Int64,\n    degree::Interpolations.Cubic{BC<:(QInchworm.utility.NeumannBC{Interpolations.OnGrid})}\n) -> Tuple{WoodburyMatrices.Woodbury, Vector}\n\n\nCompute the system used to prefilter cubic spline coefficients when using the Neumann boundary conditions.\n\nParameters\n\nT, TC: Element types.\nn:       The number of rows in the data input.\ndegree:  Interpolation degree information.\n\nReturns\n\nWoodbury matrix and the RHS of the computed system.\n\n\n\n\n\n","category":"method"},{"location":"modules/utility/#Quadratic-spline-that-allows-for-incremental-construction","page":"QInchworm.utility","title":"Quadratic spline that allows for incremental construction","text":"","category":"section"},{"location":"modules/utility/","page":"QInchworm.utility","title":"QInchworm.utility","text":"IncrementalSpline\nextend!","category":"page"},{"location":"modules/utility/#QInchworm.utility.IncrementalSpline","page":"QInchworm.utility","title":"QInchworm.utility.IncrementalSpline","text":"struct IncrementalSpline{KnotT<:Number, T<:Number}\n\nQuadratic spline on an equidistant grid that allows for incremental construction.\n\nFields\n\nknots::AbstractRange{KnotT} where KnotT<:Number: Locations of interpolation knots\ndata::Vector{T} where T<:Number: Values of the interpolated function at the knots\nder_data::Vector{T} where T<:Number: Values of the interpolated function derivative at the knots\n\n\n\n\n\n","category":"type"},{"location":"modules/utility/#QInchworm.utility.extend!","page":"QInchworm.utility","title":"QInchworm.utility.extend!","text":"extend!(\n    G_int::QInchworm.spline_gf.IncSplineImaginaryTimeGF,\n    val\n) -> Any\n\n\nExtend the underlying IncrementalSpline objects stored in G_int with a value val.\n\n\n\n\n\nextend!(\n    spline::QInchworm.utility.IncrementalSpline,\n    val\n) -> Vector{T} where T<:Number\n\n\nAdd a segment to an incremental spline by fixing value val of the interpolated function at the next knot.\n\n\n\n\n\n","category":"function"},{"location":"modules/utility/#Sobol-sequence-including-the-initial-point-(0,-0,-\\ldots)","page":"QInchworm.utility","title":"Sobol sequence including the initial point (0 0 ldots)","text":"","category":"section"},{"location":"modules/utility/","page":"QInchworm.utility","title":"QInchworm.utility","text":"SobolSeqWith0\nnext!\narbitrary_skip!","category":"page"},{"location":"modules/utility/#QInchworm.utility.SobolSeqWith0","page":"QInchworm.utility","title":"QInchworm.utility.SobolSeqWith0","text":"mutable struct SobolSeqWith0{N} <: Sobol.AbstractSobolSeq{N}\n\nSobol low discrepancy sequence including the initial point (0 0 ldots). The need for this modified version of Sobol.SobolSeq is discussed in JuliaMath/Sobol.jl#31.\n\n\n\n\n\n","category":"type"},{"location":"modules/utility/#Sobol.next!","page":"QInchworm.utility","title":"Sobol.next!","text":"next!(s::QInchworm.utility.SobolSeqWith0) -> Vector{Float64}\n\n\nReturn the next point in the Sobol sequence s.\n\n\n\n\n\n","category":"function"},{"location":"modules/utility/#QInchworm.utility.arbitrary_skip!","page":"QInchworm.utility","title":"QInchworm.utility.arbitrary_skip!","text":"arbitrary_skip!(\n    s::QInchworm.utility.SobolSeqWith0,\n    n::Integer\n)\n\n\nSkip exactly n points in the Sobol sequence s.\n\n\n\n\n\n","category":"function"},{"location":"modules/utility/#Lazy-matrix-product","page":"QInchworm.utility","title":"Lazy matrix product","text":"","category":"section"},{"location":"modules/utility/","page":"QInchworm.utility","title":"QInchworm.utility","text":"LazyMatrixProduct\nBase.pushfirst!(::LazyMatrixProduct{T}, ::Matrix{T}) where {T <: Number}\nBase.popfirst!(::LazyMatrixProduct{T}, ::Int) where {T <: Number}\neval!(::LazyMatrixProduct{T}) where {T <: Number}","category":"page"},{"location":"modules/utility/#QInchworm.utility.LazyMatrixProduct","page":"QInchworm.utility","title":"QInchworm.utility.LazyMatrixProduct","text":"mutable struct LazyMatrixProduct{T<:Number}\n\nA matrix product of the form A_N A_N-1 ldots A_1.\n\nFunctions pushfirst!() and popfirst!() can be used to add and remove multipliers to/from the left of the product. The product is lazy in the sense that the actual multiplication takes place only when the eval!() function is called. The structure keeps track of previously evaluated partial products and reuses them upon successive calls to eval!().\n\n\n\n\n\n","category":"type"},{"location":"modules/utility/#Base.pushfirst!-Union{Tuple{T}, Tuple{QInchworm.utility.LazyMatrixProduct{T}, Matrix{T}}} where T<:Number","page":"QInchworm.utility","title":"Base.pushfirst!","text":"pushfirst!(\n    lmp::QInchworm.utility.LazyMatrixProduct{T<:Number},\n    A::Array{T<:Number, 2}\n) -> Matrix{T} where T<:Number\n\n\nAdd a new matrix A to the left of the product lmp.\n\n\n\n\n\n","category":"method"},{"location":"modules/utility/#Base.popfirst!-Union{Tuple{T}, Tuple{QInchworm.utility.LazyMatrixProduct{T}, Int64}} where T<:Number","page":"QInchworm.utility","title":"Base.popfirst!","text":"popfirst!(\n    lmp::QInchworm.utility.LazyMatrixProduct{T<:Number}\n) -> Int64\npopfirst!(\n    lmp::QInchworm.utility.LazyMatrixProduct{T<:Number},\n    n::Int64\n) -> Int64\n\n\nRemove n matrices from the left of the product lmp. By default, n = 1.\n\n\n\n\n\n","category":"method"},{"location":"modules/utility/#QInchworm.utility.eval!-Union{Tuple{QInchworm.utility.LazyMatrixProduct{T}}, Tuple{T}} where T<:Number","page":"QInchworm.utility","title":"QInchworm.utility.eval!","text":"eval!(\n    lmp::QInchworm.utility.LazyMatrixProduct{T<:Number}\n) -> Matrix{ScalarType} where ScalarType<:Number\n\n\nEvaluate the matrix product lmp.\n\n\n\n\n\n","category":"method"},{"location":"modules/utility/#Serialization-using-IOBuffer","page":"QInchworm.utility","title":"Serialization using IOBuffer","text":"","category":"section"},{"location":"modules/utility/","page":"QInchworm.utility","title":"QInchworm.utility","text":"iobuffer_serialize\niobuffer_deserialize","category":"page"},{"location":"modules/utility/#QInchworm.utility.iobuffer_serialize","page":"QInchworm.utility","title":"QInchworm.utility.iobuffer_serialize","text":"iobuffer_serialize(data)\n\n\nSerialize data using an IOBuffer object.\n\n\n\n\n\n","category":"function"},{"location":"modules/utility/#QInchworm.utility.iobuffer_deserialize","page":"QInchworm.utility","title":"QInchworm.utility.iobuffer_deserialize","text":"iobuffer_deserialize(data_raw)\n\n\nDeserialize data using an IOBuffer object.\n\n\n\n\n\n","category":"function"},{"location":"modules/utility/#Range-partitioning-utilities","page":"QInchworm.utility","title":"Range partitioning utilities","text":"","category":"section"},{"location":"modules/utility/","page":"QInchworm.utility","title":"QInchworm.utility","text":"split_count\nrange_from_chunks_and_idx","category":"page"},{"location":"modules/utility/#QInchworm.utility.split_count","page":"QInchworm.utility","title":"QInchworm.utility.split_count","text":"split_count(N::Integer, n::Integer) -> Any\n\n\nReturn a vector of n integers which are approximately equal and sum to N.\n\n\n\n\n\n","category":"function"},{"location":"modules/utility/#QInchworm.utility.range_from_chunks_and_idx","page":"QInchworm.utility","title":"QInchworm.utility.range_from_chunks_and_idx","text":"range_from_chunks_and_idx(\n    chunk_sizes::AbstractVector,\n    idx::Integer\n) -> Any\n\n\nGiven a list of chunk sizes, return the range that enumerates elements in the idx-th chunk.\n\n\n\n\n\n","category":"function"},{"location":"#QInchworm.jl","page":"Home","title":"QInchworm.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package QInchworm.jl is a Julia implementation of the quasi Monte Carlo variant[1] of the inchworm algorithm[2] for solving impurity models with multiple interacting fermions. Using quasi Monte Carlo, a 1N convergence rate with the number of samples is achievable, which compares favorably to the 1sqrtN convergence of the Monte Carlo methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Below, you can find an API reference of QInchworm.jl's modules. Some parts of the API, such as handling of the atomic problem and of the pair interactions/hybridization, depend on container types from Keldysh.jl and exact diagonalization tools of KeldyshED.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There is also an example page showing how to use QInchworm.jl to solve a quantum impurity problem in thermodynamic equilibrium and to compute two-point correlation functions for it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: Inchworm quasi Monte Carlo for quantum impurities.    Hugo U. R. Strand, Joseph Kleinhenz and Igor Krivenko.    arXiv:2310.16957.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: Taming the Dynamical Sign Problem in Real-Time Evolution of Quantum    Many-Body Problems.    Guy Cohen, Emanuel Gull, David R. Reichman, and Andrew J. Millis.    Phys. Rev. Lett. 115, 266802 (2015).","category":"page"},{"location":"#Public-API","page":"Home","title":"Public API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QInchworm.expansion\nQInchworm.inchworm\nQInchworm.ppgf\nQInchworm.spline_gf\nQInchworm.utility","category":"page"},{"location":"#Internals","page":"Home","title":"Internals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QInchworm.expansion\nQInchworm.inchworm\nQInchworm.ppgf\nQInchworm.sector_block_matrix\nQInchworm.spline_gf\nQInchworm.utility\nQInchworm.mpi\nQInchworm.qmc_integrate\nQInchworm.diagrammatics\nQInchworm.topology_eval","category":"page"},{"location":"modules/sector_block_matrix/#QInchworm.sector_block_matrix","page":"QInchworm.sector_block_matrix","title":"QInchworm.sector_block_matrix","text":"","category":"section"},{"location":"modules/sector_block_matrix/","page":"QInchworm.sector_block_matrix","title":"QInchworm.sector_block_matrix","text":"CurrentModule = QInchworm.sector_block_matrix","category":"page"},{"location":"modules/sector_block_matrix/","page":"QInchworm.sector_block_matrix","title":"QInchworm.sector_block_matrix","text":"sector_block_matrix\nSectorBlockMatrix\noperator_to_sector_block_matrix\nBase.zeros(::Type{SectorBlockMatrix}, ::EDCore)\nBase.zero(::SectorBlockMatrix)\nBase.fill!(::SectorBlockMatrix, x)\nLinearAlgebra.tr(::SectorBlockMatrix)\nBase.isapprox(::SectorBlockMatrix, ::SectorBlockMatrix; atol::Real)","category":"page"},{"location":"modules/sector_block_matrix/#QInchworm.sector_block_matrix","page":"QInchworm.sector_block_matrix","title":"QInchworm.sector_block_matrix","text":"Matrix representation of operators acting in a many-body Hilbert space partitioned into invariant subspaces (sectors) of a Hamiltonian.\n\n\n\n\n\n","category":"module"},{"location":"modules/sector_block_matrix/#QInchworm.sector_block_matrix.SectorBlockMatrix","page":"QInchworm.sector_block_matrix","title":"QInchworm.sector_block_matrix.SectorBlockMatrix","text":"Complex block matrix stored as a dictionary of non-vanishing blocks.\n\nEach element of the dictionary has the form right block index => (left block index, block).\n\nObjects of this type support addition/subtraction, matrix multiplication and multiplication by a scalar.\n\n\n\n\n\n","category":"type"},{"location":"modules/sector_block_matrix/#QInchworm.sector_block_matrix.operator_to_sector_block_matrix","page":"QInchworm.sector_block_matrix","title":"QInchworm.sector_block_matrix.operator_to_sector_block_matrix","text":"operator_to_sector_block_matrix(\n    ed::KeldyshED.EDCore,\n    op::KeldyshED.Operators.OperatorExpr\n) -> Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}\n\n\nReturn the SectorBlockMatrix representation of a many-body operator op acting in the Hilbert space of the exact diagonalization problem ed.\n\n\n\n\n\n","category":"function"},{"location":"modules/sector_block_matrix/#Base.zeros-Tuple{Type{Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}}, KeldyshED.EDCore}","page":"QInchworm.sector_block_matrix","title":"Base.zeros","text":"zeros(\n    _::Type{Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}},\n    ed::KeldyshED.EDCore\n) -> Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}\n\n\nConstruct a block-diagonal SectorBlockMatrix, whose block structure is consistent with the invariant subspace partition of a given exact diagonalization object ed. All matrix elements of the stored blocks are set to zero.\n\n\n\n\n\n","category":"method"},{"location":"modules/sector_block_matrix/#Base.zero-Tuple{Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}}","page":"QInchworm.sector_block_matrix","title":"Base.zero","text":"zero(\n    A::Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}\n) -> Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}\n\n\nConstruct a SectorBlockMatrix that shares the list of stored blocks with another matrix A but has all those blocks set to zero.\n\n\n\n\n\n","category":"method"},{"location":"modules/sector_block_matrix/#Base.fill!-Tuple{Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}, Any}","page":"QInchworm.sector_block_matrix","title":"Base.fill!","text":"fill!(A::Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}, x)\n\n\nSet elements of all stored blocks of a SectorBlockMatrix A to x.\n\n\n\n\n\n","category":"method"},{"location":"modules/sector_block_matrix/#LinearAlgebra.tr-Tuple{Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}}","page":"QInchworm.sector_block_matrix","title":"LinearAlgebra.tr","text":"tr(\n    A::Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}\n) -> ComplexF64\n\n\nTrace of a SectorBlockMatrix A.\n\n\n\n\n\n","category":"method"},{"location":"modules/sector_block_matrix/#Base.isapprox-Tuple{Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}, Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}}}","page":"QInchworm.sector_block_matrix","title":"Base.isapprox","text":"isapprox(\n    A::Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}},\n    B::Dict{Int64, Tuple{Int64, Matrix{ComplexF64}}};\n    atol\n) -> Bool\n\n\nInexact equality comparison of two SectorBlockMatrix objects A and B. Block structures of the objects must agree. atol specifies the absolute tolerance for the single element comparison (zero by default).\n\n\n\n\n\n","category":"method"}]
}
